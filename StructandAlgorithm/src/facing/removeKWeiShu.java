package facing;

import java.util.Stack;

/**
 * @author renyujie518
 * @version 1.0.0
 * @ClassName removeKWeiShu.java
 * @Description
 * 给你一个以字符串表示的非负整数num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。
 * 请你以字符串形式返回这个最小的数字。
 * 示例 1 ：
 *
 * 输入：num = "1432219", k = 3
 * 输出："1219"
 * 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
 *
 * 示例 2 ：
 * 输入：num = "10200", k = 1
 * 输出："200"
 * 解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
 *
 * 示例 3 ：
 * 输入：num = "10", k = 2
 * 输出："0"
 * 解释：从原数字移除所有的数字，剩余为空就是 0 。
 *
 *
 * 来源：力扣（LeetCode）402
 * 链接：https://leetcode-cn.com/problems/remove-k-digits
 *
 * 思路：
 * 对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于 A = 1axxxA=1axxx，B = 1bxxxB=1bxxx，
 * 如果 a > ba>b 则 A > BA>B。
 * 基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小
 * 删去一个字符后，剩下的 n-1长度的数字序列就形成了新的子问题，可以继续使用同样的策略，直至删除 k次
然而暴力的实现复杂度最差会达到 O(nk)O(nk)（考虑整个数字序列是单调不降的），因此我们需要加速这个过程。

考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，
栈中的元素代表截止到当前位置，删除不超过 k次个数字后，所能得到的最小整数。
根据之前的讨论：在使用 k 个删除次数之前，栈中的序列从栈底到栈顶单调不降。

解法：历字符串 s，若当前栈不为空并且栈顶元素的值大于当前遍历的元素值并且移除元素的个数没有达到要求 k，则栈顶元素出栈，count 值加 1。

若当前遍历的元素比栈顶元素的值要大，则直接将该元素压栈。

若当前遍历的元素值为 " 0 " 并且栈为空，则直接跳过这次循环（要保证栈底的元素不能为 " 0 "，因为题目要求 num 不会包含任何前导零，就是不能用 " 0 " 来开头）。

若遍历完整个字符串而 count < k（移除的元素个数没有达到要求，示例：num = "123456", k = 3），此时直接将栈中的前三个元素依次出栈，即 " 654 " 出栈剩下的 " 321 " 翻转一下，即为最小值。

若当前栈为空（去掉一个最大的元素后，其余元素均为 " 0 "），则直接返回 " 0 " 即可。


示例：num = "100", k = 1，初始：count = 0
i = 0，1 入栈 -> stack：(1)；
i = 1，0 < 1 且 count < 1 -> stack：()，count = 1；
i = 2，0 = 0，当前元素值为 0，并且栈为空，则直接跳过此次遍历；

因为栈为空，所以最终返回 "0"。
如果当前遍历的元素比栈顶元素小，则要将栈顶元素出栈，不用管后面有没有比它更大的，为什么？
因为栈顶的元素比当前遍历的元素值要大，将栈顶元素出栈，小的那个元素入栈，高位变小，变小的幅度大于低位变小的幅度（十位从 3 变到 2 的幅度，要比个位从 9 变到 1 的幅度大）。

解法：
遍历字符串 s，若当前栈不为空并且栈顶元素的值大于当前遍历的元素值并且移除元素的个数没有达到要求 k，则栈顶元素出栈，count 值加 1。
若当前遍历的元素比栈顶元素的值要大，则直接将该元素压栈。
若当前遍历的元素值为 " 0 " 并且栈为空，则直接跳过这次循环（要保证栈底的元素不能为 " 0 "，因为题目要求 num 不会包含任何前导零，就是不能用 " 0 " 来开头）。
若遍历完整个字符串而 count < k（移除的元素个数没有达到要求，示例：num = "123456", k = 3），此时直接将栈中的前三个元素依次出栈，即 " 654 " 出栈剩下的 " 321 " 翻转一下，即为最小值。
若当前栈为空（去掉一个最大的元素后，其余元素均为 " 0 "），则直接返回 " 0 " 即可。


示例：num = "100", k = 1，初始：count = 0
i = 0，1 入栈 -> stack：(1)；
i = 1，0 < 1 且 count < 1 -> stack：()，count = 1；
i = 2，0 = 0，当前元素值为 0，并且栈为空，则直接跳过此次遍历；
因为栈为空，所以最终返回 "0"。

如果当前遍历的元素比栈顶元素小，则要将栈顶元素出栈，不用管后面有没有比它更大的，为什么？
因为栈顶的元素比当前遍历的元素值要大，将栈顶元素出栈，小的那个元素入栈，高位变小，变小的幅度大于低位变小的幅度（十位从 3 变到 2 的幅度，要比个位从 9 变到 1 的幅度大）。


 * @createTime 2021年08月04日 16:43:00
 */
public class removeKWeiShu {
    public static String removeKWeiShu(String num, int k) {
        //特殊情况 当k = length时，直接返回0
        if (k == num.length()) {
            return "0";
        }
        char[] datas= num.toCharArray();
        Stack<Character> stack = new Stack<>();
        for (char data : datas) {
            while (!stack.isEmpty() && data < stack.peek() && k > 0) {//栈顶元素相当于门槛，一旦出现比门槛小的，弹出门槛，别忘了宗旨，栈里尤其是栈顶要小的
                stack.pop();
                k--;
            }
            //特殊情况  当栈为空且当前位为0 我们不需要将其入栈
            //我们不需要将0入栈，因为0如果处于栈底，没有比它更小的值所以它不会被移除，我们只有在最后才有机会处理它。
            //因为我们的010 = 10 ，首位0是需要在最后去掉的。
            //所以我们这里可以直接不让其入栈，continue掉这次循环，也不改变K值，这样我们最后出栈处理时就不用考虑啦
            if (stack.isEmpty() && data == '0') {
                continue;
            }
            //剩余的情况就是压栈（若当前遍历的元素比栈顶元素的值要大，则直接将该元素压栈）
            stack.push(data);
        }
        //若遍历完整个字符串而移除的元素个数没有达到要求(k还大于0)，此时直接将栈中剩余需要去除的元素依次出栈
        while (!stack.isEmpty() && k > 0) {
            stack.pop();
            k--;
        }
        //这个是最后栈为空时，删除一位，比如我们的10，删除一位为0，按上面逻辑我们会返回""，所以我们让其返回"0"
        if(stack.isEmpty()){
            return "0";
        }
        //反转并返回字符串
        StringBuilder str = new StringBuilder();
        while (!stack.isEmpty()) {
            str.append(stack.pop());
        }
        return str.reverse().toString();
    }
}
